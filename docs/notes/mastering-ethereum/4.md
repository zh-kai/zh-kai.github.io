# 交易

## 交易构成

- nonce: 序列编号，由外部账号提供，防止重放攻击
- gas price: 交易发起方愿意支付的 gas 价格
- gas limit: 交易发起方愿意支付的最大 gas 数量
- recipient: 目标以太坊地址
- value: 发送给目标地址的以太坊数量
- data: 附在交易中的可变长度数据
- v,r,s: 由外部账户提供的椭圆曲线签名的三个组成部分

### nonce

nonce 是一个数值，**从 0 开始**，等于这个地址发出的交易的数量，这个值不会显式的存在链上，而是通过计算地址已确认的交易数量动态计算的。
nonce 的重要性：

1. 确保**交易顺序**。当要进行两笔交易 分别为 重要的 2e & 不重要 3e 但是余额只有 4e，这个时候会有一笔交易失败，对于发送方来说，希望 2e 被确认，但是节点在接收到交易的顺序是不确定的，某些节点可能会优先接受 3e 的交易并打包上链。如果 nonce 存在，3e 的 nonce 会小于 2e 的 nonce，优先接受到 3e 交易的节点会忽略此交易，知道前一个 nonce 的交易被确认。
2. 防止**重放攻击**。加入地址里有 10e，然后发送了 1e 给另一个地址，在没有 nonce 的情况下，别人可以轻易复制该交易的原始信息，一次又一次的重放该交易，直到余额被消耗殆尽。如果 nonce 存在，那么交易就是唯一的，别人无法通过简单的复制交易内容来重放交易。

### 想合约发送带 data 的交易

data 数据的内容是通过十六进制编码的

- 函数选择器：被调用函数原型的 keccak-256 哈希值的前 4 个字节，这允许 EVM 准确识别被调函数
- 函数参数：根据 EVM 多种实现规则定义的编码结构

## 数字签名

以太坊使用的椭圆曲线数字签名算法，ECDSA。

### 创建签名

在以太坊中，被签名的消息是经过 RLP 编码的交易数据包的 Keccak-256 的哈希值，签名密钥是外部账户私钥 `Sig = F_sig(F_keccak256(m), k)`，其中：

- k：私钥
- m：经过编码的数据包
- F_keccak256：Keccak-256 哈希函数
- F_sig：签名算法
- Sig：生成的数字签名，通常包含两部分 r，s `Sig = (r, s)`

验证签名需要 r, s, m, 公钥

### ECDSA 数字签名算法

创建签名数学过程

1. 生成临时密钥对，用于计算 r，s，临时密钥对主要有以下两点决定
   - 一个密码学安全的随机数 q，作为临时私钥
   - 从 q 生成临时公钥 Q，以及椭圆曲线上的生成点 G，数字签名中的 r 就是 Q 的 x 值
2. 在此基础上计算 s `s === q^(-1)(Keccak256(m) + r * k)(mod p)`
   - q：临时私钥
   - r：临时公钥的 x 坐标
   - k：用于签名的私钥
   - m：被签名的交易数据包
   - p：椭圆曲线上的素数阶

验证签名数学过程，是一个相反的操作，使用 r，s 来计算 Q，Q 是椭圆曲线上一点

1. 检查所有输入的正确性
2. 计算 `w = s^-1 mod p`
3. 计算 `u1 = Keccak256(m) * w mod p`
4. 计算 `u2 = r * w mod p`
5. 计算椭圆曲线上的点 `Q = u1 * _G + u2 * K(mod p)`

   - r, s：数字签名的值
   - K：签名方的公钥
   - m：被签名的交易数据包
   - G：椭圆曲线生成点
   - p：椭圆曲线上的素数阶

如果得到 Q 的 x = r，则签名合法。

> 特殊变量 v 代表两件事：链 ID，以及帮助 ECDSArecover 函数检查签名的恢复标识符，被计算为 27/28 或者是 链 ID + 35/36。

### 公钥恢复

给定 s，r 我们可以计算出两个可能的公钥，`K1 = r^-1 (sR - zG)` / `K2 = r^-1 (sR' - zG)`

因为根据给定的 r 可以得到 x，但是椭圆曲线是关于 x 轴对称的，为了让事情变得高效，引入了 v，根据 v 的奇偶可以得知哪一个是临时公钥，从而计算得到公钥。

- 2023-3-7 149
