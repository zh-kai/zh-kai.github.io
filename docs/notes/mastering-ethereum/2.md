# 以太坊背后的密码学

**陷门函数**：正向计算容易，反向推导困难，但是在得知一些私密信息的情况下，可以轻易反向计算。

**私钥**：一组随机获取的数字，以太坊私钥基本就是在 1 到 2^256 之间选择数字，要保证选择的过程不可预测 & 不可重复

**公钥**：通过对私钥使用椭圆曲线的乘法运算得出，这个乘法运算基本不可逆：`PublicKey = PrivateKey * G`，G 是一个常量点，称为生成点。

## 椭圆曲线

- 以太坊使用 secp256k1 椭圆曲线算法
- 加法：给定椭圆曲线上两点 P1 P2，椭圆曲线上存在第三个点 满足 `P3 = P1 + P2`。第三个点的计算就是在两个点之间画一条直线，这条线会与椭圆曲线存在唯一交点。如果 P1 P2 是同一个点，那么 P1 P2 之间的直线就是 P1(P2) 点的切线，这条切线会与椭圆曲线存在唯一交点
- 无限远点：类似于数学中的 0，一些情况（P1 P2 的 x 相同，但是 y 不同）这时两点之间的直线是垂直的，这种情况下 P3 就是无限远点
- 乘法：由加法衍生，对于椭圆曲线上的一点 P，若 k 是整数，则 `k * P = P + P + ... + P`

## 生成公钥

使用椭圆曲线上预先定义好的生成点 G，来产生的另一个点就是公钥：`PublicKey = PrivateKey * G`。生成点由 secp256k1 定义，在所有 secp256k1 中，生成点保持不变，所有通过该算法生成的公钥都使用了该生成点。因为生成点不变，所以通过同样的 PrivateKey 总会得到同样的 PublicKey，也就是一个私钥对应一个地址。

通过计算得到的 PublicKey 为一个点 `PublicKey = (x,y)`，以太坊采用 130 个十六进制字符表示公钥，这是由 SECG 发布的行业标准的序列化方式，标准定义了 4 种前缀：
| 前缀 | 含义 | 长度(字节) |
|:----:|:---------:|:---:|
| 0x00 | 无穷远点 | 1 |
| 0x04 | 未压缩点 | 65 |
| 0x01 | 偶数 y 压缩的点 | 33 |
| 0x03 | 奇数 y 压缩的点 | 33 |

以太坊使用未压缩的公钥，使用前缀为 `0x04`，所以公钥编码后的形态为 `04 + x + y`。

## 哈希函数

可以将任意长度数据映射成固定长度数据的数学函数，输入为预映射 / 消息 / 输入数据，输出为哈希。

加密哈希函数是一种*单向*的哈希函数，并且是 “多对一” 的函数，发现具有相同哈希的两个输入问题称为*哈希碰撞问题*，哈希性质越好，哈希碰撞的概率就越小（对于以太坊来说几乎不可能）。哈希函数有以下特性：

- 确定性：同样的输出总会产生同样的哈希
- 可验证性：计算任意输入信息量的哈希运算非常高效（线性的计算性能）
- 无关联性：对于输入的微小改变，都会使输出发生巨大的变化，并且这种变化和之前的消息没有关联性
- 不可逆性：从哈希反向计算得到输入是不现实的，只能用暴力搜索
- 碰撞保护性：几乎不可能找到得到同样哈希的两个不同的输入（对于防止伪造以太坊数字签名尤为重要）

密码学哈希函数应用：

- 数据指纹
- 数据一致性（错误侦测）
- 工作量证明
- 身份认证（密码哈希和密钥延伸）
- 伪随机数生成
- 消息承诺
- 唯一标识符

## 以太坊地址

以太坊地址是唯一标识，从公钥 / 合约通过单向哈希函数 **Keccak-256** 计算而来。通过 Keccak-256 将编码后的公钥进行哈希，然后只保留后 20 位（40 位十六进制字符）作为以太坊的地址。

以太坊地址不本身不区分大小写，但是为了保护地址完整性，避免人为的输入错误，提出了 **EIP-55: 十六进制编码地址的大小写校验**。不支持 EIP-55 的钱包会忽略大小写，支持的钱包可以通过大小写来验证地址的准确性。实现方式如下：

1. 针对全小写的地址进行一次 hash，不包括 0x。
2. 依次检查地址中的字母对应的 hash，如果 hash 的十六进制大于/等于 8，就把对应的地址字母大写
